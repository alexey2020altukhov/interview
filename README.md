# Собеседование Junior+
## ?. ODM
?

## ?. ООП
**Объектно-ориентированное программирование (ООП)** - это методология программирования с использованием объектов и классов. 

**Класс в Java** - это шаблон для создания объекта, а **объект** - это экземпляр класса. 
Класс определяет структуру и поведение, которые будут совместно использоваться набором объектов. Класс содержит переменные и методы, которые называются элементами класса, членами класса.

Выделяют следующие основные принципы ООП:  

**1. Абстракция** - означает выделение наиболее значимой информации и исключение из рассмотрения незначимой. С точки зрения программирования это правильное разделение программы на объекты. Абстракция позволяет отобрать главные характеристики и опустить второстепенные.  

**2. Инкапсуляция** - ограничение доступа к данным и возможностям их изменения. Инкапсуляция достигается с помощью **модификаторов доступа**:
- public - доступ из любого места программы;
- protected - доступ на уровне пакета и классов-наследников;
- default - доступ на уровне пакета;
- private - доступ только на уровне класса.

**3. Наследование** - механизм, который позволяет описать новый класс на основе уже существующего. При этом свойства и функциональность родительского класса заимствуются новым классом.  

Класс, от которого наследуются свойства и методы, называется **суперклассом (родительским классом)**. Классы, которые наследуют их, называются **подклассами (дочерними классами)**. 

Для создания дочернего класса используется ключевое слово `extends`. Для обращения к суперклассу из подкласса используется ключевое слово `super`.

_Прим:_
Множественное наследование классов в Java не допускается.

**4. Полиморфизм** - разная реализация одного и того же интерфейса.  
Полиморфизм в Java бывает статическим (полиморфизм времени компиляции) и динамическим (полиморфизм времени выполнения).  

**Перегрузка метода** является примером статического полиморфизма, а **переопределение метода** – примером динамического полиморфизма.

**Перегрузка метода** - механизм, при котором несколько методов имеют одинаковое название, но разные типы, порядок и количество параметров.
```
public int method(int a) { ... }
public int method(double a) { ... }
public int method(int a, String b) { ... }
public int method(String a, int b) { ... }
```
**Переопределение метода** - это изменение поведения в дочернем классе  уже существующего  в суперклассе метода (override).  В новом методе должны быть те же сигнатура и тип возвращаемого результата, что и у метода родительского класса.

_Прим:_
Методы с модификатором private нельзя переопределить.

## ?. Принципы SOLID
**1. Single Responsibility Principle - принцип единственной ответственности**.  
Каждый класс должен отвечать только за одну задачу. Если же существуют методы, которые не соответствуют цели сущестствования класса, их необходимо вынести за рамки этого класса.

**2. Open Closed Principle (Принцип открытости/закрытости)**.  
Классы должны быть открыты для расширений, но закрыты для модификаций. Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим.

**3. Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков)**.  
Подклассы должны дополнять, а не замещать поведение базового класса. Если объект базового класса заменить объектом его производного класса, то программа должна продолжить работать корректно. Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат.

**4. Interface Segregation Principle (Принцип разделения интерфейса)**.  
Лучше, когда есть множество специализированных интерфейсов, чем один общий. Не следует ставить клиент в зависимость от методов, которые он не использует. Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.


**5. Dependency Inversion Principle (Принцип инверсии зависимостей)**.  
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.

## ?. Базовые паттерны проектирования
Паттерны проектирования — это устоявшиеся удачные решения самых распространнёх проблем, возникающих при проектировании и разработке программ или их частей.  

**1. Порождающие**  
Эти паттерны решают проблемы обеспечения гибкости создания объектов.  

**Singleton** - обеспечиват существование в системе ровно одного экземпляра некоторого класса.  
```
class Singleton {

	private Singleton instance;

	private Singleton() {}

	public static Singletot getInstance() {
		if (instance == null)
			instance = new Singleton();
		return instance;
	}
}
```

**Factory Method** - делегирует процесс создания объектов классам-наследникам.  

**Prototype** - клонирует объекты на основании некоторого базового объекта.  

**Builder** - отделяет процесс создания комплексного объекта от его представления.  

**Abstract Factory** - описывает сущность для создания целых семейств взаимосвязанных объектов.  

**2. Структурные**  
Эти паттерны решают проблемы эффективного построения связей между объектами.  

**Proxy** - предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).  
```
//Интерфейс
public interface WebServer {

    void makeRequest(String url);
}

//Класс, выполняющий фактическую работу
public class RealWebServer implements WebServer {
    
    @Override
    public void makeRequest(String) { ... }
}

//Прокси-класс
public class ProxyWebServer implements WebServer {

    private RealWebServer realServer;
    private List<String> blockedSites = new ArrayList<>();

    public ProxyWebServer() { 
	this.realServer = new RealWebServer(); 
    }

    public void blockWebsite(String url)  {
        this.blockedSites.add(url);
    }

    @Override
    public void makeRequest(String url) {
        if(!blockedSites.contains(url)) {
            this.realServer.makeRequest(url);
        }
        else {
 	    System.out.println("This website is blocked. Contact your administrator");
        }
    }
}
```

**Adapter** - на основании некоторого класса создает необходимый клиенту интерфейс.  

**Facade** - описывает унифицированный интерфейс для облегчения работы с набором подсистем.  

**Composite** - работает с базовыми и составными объектами единым образом.  

**Decorator** - динамически добавляет новую функциональность некоторому объекту, сохраняя его интерфейс.

**Bridge** - разделяет абстракцию от интерфейса, позволяя им меняться независимо.  

**Flyweight** - эффективно работает с огромным количеством схожих объектов.

**3. Поведенческие**  
Эти паттерны решают проблемы эффективного взаимодействия между объектами.


**Strategy** - описывает набор взаимозаменяемых алгоритмов с единым интерфейсом. 

**Iterator** - обеспечивает доступ к коллекциям объектов без раскрытия внутреннего устройства этих коллекций.  

**Observer** - создает объект для отслеживания изменений в подсистеме и нотификации других подсистем.  

**Memento** - сохраняет внутреннее состояние объекта для последующего использования без нарушения инкапсуляции.  

**Command** - описывает объект, представляющий собой некоторое действие, которое можно выполнить в необходимый момент.  

**Interpreter** - определяет способ вычисления выражений некоторого языка.  

**Mediator** - создает объект, которые регулирует взаимодействие между набором подсистем.  

**State** - позволяет объекту менять свое поведение при изменении его внутреннего состояния.  

**Template** method - описывает алгоритм, возлагая реализацию некоторых частей алгоритма на подклассы.  

**Visitor** - отделяет алгоритм от структуры, с которыми алгоритм работает.  

**Chain of responsibility** - пропускает некоторый запрос через набор обработчиков событий, до тех пор пока запрос не будет обработан.
